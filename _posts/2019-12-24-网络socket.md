---
layout:     post
title:      网络socket
subtitle:   exception
date:       2019-12-24
author:     BY
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - web
---

## 五层协议

* 网络层:IP源ip+目的IP
  IP标识的是网络上的唯一- 的一台结点(主机)
* 传输层: Port (端口)    源port +目的port
  port标识的是主机上的唯----个进程
  进程(人)     端口(电话号码)
  人可以有多个电话号码，但是一个电话号码只能属于一个人(备注)
  
* ip+port标识网络，上的唯一一台主机上的唯一一个进程
* 网络传输分双方
* 操作系统提供给用户态的网络接口是socket (套接字)

***四元组：本地ip+本地port+目标ip+目标port***

***五元组：加一个协议TCP/UDP***


### UDP

***无连接/不可靠(缺点) /面向报文(粗略看作优点)***

    分包发送，一步一步，发几次收几次

> UDP服务器角色

    1.选址开店  DatagramSocket (port) ; bind一个端口
    while true:
      2.等待客人上门    socket. receive() ; //客人一来就点菜了
      3.做客人要的菜    业务相关
      4.把菜端出去   socket. send() ;
    5.饭店关门    socket. close() ; 


> UDP客户端角色

    1.去哪家饭店   DatagramSocket(); connect/receive //点菜了
    2.等待上菜    socket. receive()
    3.离开      socket. close ()

> ***1.echo服务:你发什么，我回什么***

```java
//为了代码的复用性和可移植性，在中文操作系统中，getBytes方法返回的是一个GBK或者GB2312的中文编码的字节数组，
// 其中中文字符，各占两个字节。而在英文平台中，一般的默认编码是“ISO-8859-1”，每个字符都只取一个字节。
//因此，尽量把代码以byte[] 字节数组类型传输
public class Server {
    public static void main(String[] args) throws IOException {
        //开始监听连接请求
        DatagramSocket socket = new DatagramSocket(8888);
        while (true) {
            //准备了一个接收缓冲区    最大接收4096字节数据
            byte[] buffer = new byte[4096];
            //创建了一个接收报文
            DatagramPacket receivePacket = new DatagramPacket(buffer, 0, buffer.length);
            //当 receive 返回时，OS 就会把对方发送过来的数据填充到接收缓冲区中
            socket.receive(receivePacket);

            int len = receivePacket.getLength();
            //字节转字符串类型
            //这样就收到了发过来的消息
            String message = new String(buffer, 0, len, "UTF-8");
            System.out.println("收到了消息：" + message);
            //发什么回什么
            String echoMessage = message;
            //设置发送缓冲区
            //字符(串)转字节类型
            byte[] sendBuffer = echoMessage.getBytes("UTF-8");
            //数据封装
            DatagramPacket sendPacket = new DatagramPacket(sendBuffer,
                    0,
                    sendBuffer.length,
                    receivePacket.getAddress(),
                    receivePacket.getPort()
            );
            //发送封装的数据
            socket.send(sendPacket);
        }
    }
}
```

```java
public class Client {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        DatagramSocket socket = new DatagramSocket();
        while(true) {
            System.out.println("请输入要发送的信息");
            String message = scanner.nextLine();
            //String message = "jesus";
            byte[] sendBuffer = message.getBytes("UTF-8");
            //获取本机地址
            InetAddress address = InetAddress.getLocalHost();
            //获取网络连接
            /*
            InetAddress address = InetAddress.getByAddress(
                    new byte[] { (byte)192, (byte)168, (byte)137, 1 }
            );  
            */
            int port = 8888;
            //发送需要知道对方(服务端的地址和端口号)
            DatagramPacket sendPacket = new DatagramPacket(sendBuffer,
                    0,
                    sendBuffer.length,
                    address,
                    port
            );
            socket.send(sendPacket);

            byte[] receiveBuffer = new byte[4096];
            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer,
                    0,
                    receiveBuffer.length
            );
            socket.receive(receivePacket);
            //字节转字符并且打印字符串
            String echoMessage = new String(receiveBuffer, 0, receivePacket.getLength(), "UTF-8");
            System.out.println(echoMessage);
            //socket.close();
        }
    }
}
```

> ***2.英文翻译查询服务***

```java
public class Server {
    private static Map<String, String> dictionnary = new HashMap<>();

    static {
        try {
            InputStream is = new FileInputStream("字典.txt");
            //一次一次读
            Scanner scanner = new Scanner(is,"UTF-8");
            while (scanner.hasNext()) {
                String line = scanner.nextLine();
                String[] kv = line.split(":");
                dictionnary.put(kv[0],kv[1]);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    /*
    static {
        dictionnary.put("cat","猫");
        dictionnary.put("dog","狗");
        dictionnary.put("fish","鱼");
    }
    */
    private static String translate(String english){
        return dictionnary.getOrDefault(english,"看不懂");
    }

    public static void main(String[] args) throws IOException {
        //开始监听连接请求
        DatagramSocket socket = new DatagramSocket(8888);
        while (true) {
            //准备了一个接收缓冲区    最大接收4096字节数据
            byte[] buffer = new byte[4096];
            //创建了一个接收报文
            DatagramPacket receivePacket = new DatagramPacket(buffer, 0, buffer.length);
            //当 receive 返回时，OS 就会把对方发送过来的数据填充到接收缓冲区中
            socket.receive(receivePacket);

            int len = receivePacket.getLength();
            //字节转字符串类型
            //这样就收到了发过来的消息
            String message = new String(buffer, 0, len, "UTF-8");
            System.out.println("收到了消息：" + message);
            //把翻译的信息回过去
            String echoMessage = translate(message);
            //设置发送缓冲区
            //字符(串)转字节类型
            byte[] sendBuffer = echoMessage.getBytes("UTF-8");
            //数据封装
            DatagramPacket sendPacket = new DatagramPacket(sendBuffer,
                    0,
                    sendBuffer.length,
                    receivePacket.getAddress(),
                    receivePacket.getPort()
            );
            //发送封装的数据
            socket.send(sendPacket);
        }
    }
}
```

```字典
cat:猫
dog:狗
fish:鱼
```

[时序图](https://github.com/q1206271031/photo/raw/master/%E7%BD%91%E7%BB%9Csocket/%E7%BF%BB%E8%AF%91%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

[从网络原理角度](https://github.com/q1206271031/photo/raw/master/%E7%BD%91%E7%BB%9Csocket/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%B9%E9%9D%A2.png)

***calculator计算器版***

```java
public class Server {
    private static String parse(String message){
        String[] items = message.split(" ");
        int a = Integer.parseInt(items[0]);
        String operator = items[1];
        int b = Integer.parseInt(items[2]);

        int r;
        switch (operator){
            case "+": r = a+b;break;
            case "-": r = a-b;break;
            case "*": r = a*b;break;
            default: r = -1;
        }
        return String.valueOf(r);
    }

    public static void main(String[] args) throws IOException {
        //开始监听连接请求
        DatagramSocket socket = new DatagramSocket(8888);
        while (true) {
            //准备了一个接收缓冲区    最大接收4096字节数据
            byte[] buffer = new byte[4096];
            //创建了一个接收报文
            DatagramPacket receivePacket = new DatagramPacket(buffer, 0, buffer.length);
            //当 receive 返回时，OS 就会把对方发送过来的数据填充到接收缓冲区中
            socket.receive(receivePacket);

            int len = receivePacket.getLength();
            //字节转字符串类型
            //这样就收到了发过来的消息
            String message = new String(buffer, 0, len, "UTF-8");
            System.out.println("收到了消息：" + message);
            //返回计算结果
            String echoMessage = parse(message);
            //设置发送缓冲区
            //字符(串)转字节类型
            byte[] sendBuffer = echoMessage.getBytes("UTF-8");
            //数据封装
            DatagramPacket sendPacket = new DatagramPacket(sendBuffer,
                    0,
                    sendBuffer.length,
                    receivePacket.getAddress(),
                    receivePacket.getPort()
            );
            //发送封装的数据
            socket.send(sendPacket);
        }
    }
}
```

### TCP

***面向连接/可靠的/面向流的***

    发送的一条一条的数据，收到的时候会是一整条数据






