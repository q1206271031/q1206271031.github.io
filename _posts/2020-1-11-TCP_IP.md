### TCP(传输控制协议)

***面向连接/可靠的/面向流的***

    网络层:IP源ip+目的IP IP标识的是网络上的唯一的一台结点(主机)
    五元组:通过五个信息为了确定一个传输层上的数据通道(联合主键)
    协议+本地IP+本地端口+远端IP+远端端口

    

> TCP协议段格式

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/TCP%20%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.png)

> 几个标志位含义

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/8%20%E4%B8%AA%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%90%AB%E4%B9%89.png)

    序列号作用：  1.知道确认的是哪些数据
                 2.接收方通过序列号来进行数据去重
                 3.有序到达
    ASN:下一次应该发送的数据的起始编号
    超时重传(建立在有确认应答的基础上)

    校验和：是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端
            之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃

> TCP/IP通讯过程

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/TCP%2CIP%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png)

***应用层：HTTP协议***

> HTTP格式(请求和响应)

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/HTTP_Request.png)

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/RHTTP_Response.png)

```java
//请求
POST /index.html HTTP/1.1
HOST: www.XXX.com
User-Agent: Mozilla/5.0(Windows NT 6.1;rv:15.0) Firefox/15.0

Username=admin&password=admin
```

```java
//响应
HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
```

> 三次握手，四次挥手

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

> 加上状态的三次握手，四次挥手

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

    第一次握手：客户端主动发起连接，向服务端发送 SYN 请求（SYN=1，seq=x）；服务端确认客户端发送功能正常。
    第二次握手：服务端接收到客户端发送的 SYN 请求，发送 ACK 确认（SYN=1, ACK=1, ack=x+1, seq=y）客户端确认
                服务端接收和发送功能正常。
    第三次握手：客户端接收到服务端返回的 ACK 确认信息，发送连接建立确认 ACK （ACK=1，ack=y+1）服务端确认客
                户端接收功能正常，连接建立。
    接下来就可以开始发送数据了。

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

    第一次挥手：客户端发送 FIN 请求关闭连接（FIN=1，seq=u），表示客户端不再发送数据，但是还可能接收服务端
                发送的数据。
    第二次挥手：服务端发送接收确认 ACK （ACK=1，seq=v，ack=u+1），表示服务端收到了客户端的关闭请求，不再
                接收客户端的数据，但仍可以向客户端发送数据。
    第三次挥手：服务端发送 FIN 关闭连接（FIN=1，ACK=1，seq=w，ack=v+1），服务端表示不再发送数据。
    第四次挥手：客户端发送接收确认 ACK（ACK=1，ack=w+1，seq=u+1），客户端表示知道了，完成断开 TCP 连接。

> 为什么“握手”是三次，“挥手”却要四次？

    TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN
    与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器
    端收到了它的请求报文。 即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不
    多也不少，正好让双方明确彼此信息互通。

    > TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"
    传输的。为何建立连接时一起传输，释放连接时却要分开传输？  建立连接时，被动方服务器端结束CLOSED阶段进入“
    握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。 > * 释放连接时，被动方服务器，突然
    收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认
    收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

> RESET

***1.请求发送给一个没有LISTEN的port, 一定Reset***

    问题场景:写了一个客户端，连接不上服务器

***2.连接已经建立了,但中间网络断了，一方尝试write数据，超时时间过长，认为网络已经断开了***

    1) 通知应用层这个情况，应用层在write的时候报reset
    2)给对方网络发送一个Reset

RESET不需要ACK

> 流量控制

发送速率= f(接收方的接收能力，路上拥堵情况);

> 滑动窗口

![](https://github.com/q1206271031/photo/raw/master/TCP_IP/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png)
















