### JAVAWeb

> 冯诺依曼结构

![](https://github.com/q1206271031/photo/raw/master/JAVAweb/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.png)

> 除此之外JVM内存模型分为：

![](https://github.com/q1206271031/photo/raw/master/%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/JVM.png)

***其中***

    栈：方法调用，每调用一个方法，生成一个调用栈帧
        局部变量是在栈帧--局部变量在栈里
    堆：对象--属性
    方法区：类信息(Class对象)--方法/静态属性
    
> ***程序调度***
CPU从一个进程的执行切换到另一个进程的执行

> 什么情况下会发生进程调度:

    1.优先级更高的进程抢占(CPU)
    2.进程运行结束
    3. 等待外部事件(输入和输出的响应)
    4.时间片耗尽的时候(重要)
    5.主动放弃

> 类的加载：JVM在运行过程中把类字节码文件从硬盘加载到内存的过程

0.谁负责加载             类加载器
1.从哪找类字节码文件
2.放置的区域             方法区
3.过程

```java
public class Main extends Thread {
    @Override
    public void run() {
        while (true) {
            System.out.println("我是启动起来的线程");
        }
    }

    // jconsole
    public static void main(String[] args) {
        //创建子线程
        Main main = new Main();
        //启动线程
        main.start();
        //主线程程序
        while (true) {
            System.out.println("我是主线程");
        }
    }
```

### 多线程
为什么要使用多线程-多线程的优势

    1.使用多线程有可能提升效率
    某些场景下，如果任务的数量不够，启动线程占用的时间反倒成为耗时较多的，导致多线程不一定快
    2.某些场景下，主线程会阻塞，导致必须使用多线程工作: 
        (IO相关)
        模型更简单
        NIO/协程
    3. 某些场景下，主线程不允许做大量的计算，导致大量计算必须放到多线程中:
        (GUI图形界面开发)

> 在javaFX中

```javaFX
//添加Button按钮，提供onAction方法
<Button text="点我" GridPane.columnIndex="0" GridPane.rowIndex="0" onAction="#onButton"/>

public class Controller {
    @FXML public void onButton(ActionEvent actionEvent) {
        System.out.println("hello world");
        //主线程被卡死
        while (true) {}
    }
```

> 如何创建多线程对象Thread对象

    1.继承Thread类+覆写run方法
    2.实现Runnable接口+覆写run方法
      把Runnable 对象作为Thread类的构造方法的参数
    3. Thread 类也实现了Runnable 接口

```java
public static void main(String[] args) {
        //方法一 继承Thread， 并且直接启动
        MyThread myThread = new MyThread();
        myThread.start();
        //方法二 实现Runnable， 作为参数
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        //方法三 继承Thread，, 作为参数
        MyThread myThread2 = new MyThread();
        Thread thread1 = new Thread(myThread2);
        thread1.start();
    }
```

> 线程的匿名类和lambda

```java
//匿名类
new Thread(new Runnable() {
             @Override
             public void run() {
                 for (int x = 0; x < 100; x++) {
                     System.out.println("java" + "--" + x);
                 }

//匿名类
        Thread t = new Thread() {
            @Override
            public void run() {
            }
        };
        t.start();
//lambda
        Thread t2 = new Thread(
                () -> {}
        );
        t2.start();
    }
```

> 方法覆写

    方法名相同
    参数列表相同
    返回值类型“相同”
    访问限定符不能更小
    声明抛出的异常列表要“相同

```java
class Animal {}
class Bird extends Animal {}

class AnimalException extends Exception {}
class BirdException extends AnimalException {}

public class MethodOverride {
    public Animal getAnimal() throws AnimalException {
        return null;
    }
}

class MethodOverrideChild extends MethodOverride {
    @Override
    public Bird getAnimal() throws BirdException {
        return null;
    }
}
```

> 线程相关操作

***1.启动线程：***

start(),run()

***2.A线程要终止线程：***
        
        interrupt();建议性终止
        B如何知道A线程要终止B:
        1. B正在睡眠(sleep/wait/ join)
           通知是以异常的形式给到: InterruptedException,状态保持false
        2.B没有在睡眠,状态被修改为true
          1) isInterruped() 判断A是否让B死
            只获取当前状态，不修改状态的值
          2) Thread.interrupted ()
            获取当前状态，并把状态改为false

***3.多线程优势***

    1.提升速度
    2.编程模型简单

***4.JVM停止条件***

    所有非精灵线程都退出，才会退出，并不是主线程退出就退出。而所谓守护线程是指在程序运行的时候在后台提供一
    种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分
    。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任
    何非守护线程还在运行，程序就不会终止。

```java
public static void main(String[] args) {
        // Thread.currentThread()   静态方法
        // 获取当前线程的 Thread 对象
        Thread currentThread = Thread.currentThread();
        System.out.println(currentThread.getId());
        System.out.println(currentThread.getName());
        //优先级(越高越好)
        System.out.println(currentThread.getPriority());
        System.out.println(currentThread.getState());
        //是否后台线程
        System.out.println(currentThread.isDaemon());
        //是否存活
        System.out.println(currentThread.isAlive());
        //是否被中断
        System.out.println(currentThread.isInterrupted());
```

> 状态切换的理解

    1.代码运行的前提是有CPU
    2.只有RUNNABLE 有资格争抢CPU
    3.大部分状态背后都有一个数据结构在管理该状态下的线程

> 线程安全:

    如果进程运行的结果和预期一致，就是线程安全的(多次运行)
    
> 类/对象线程安全:

    该类或者该对象在使用时，不需要你再考虑线程问题，可以认为它是线程安全的

> JAVA内存区域划分

![](https://github.com/q1206271031/photo/raw/master/JAVAweb/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png)

    PC/栈( java栈/本地方法栈)    私有
    堆/方法区/常量池             共享
    有共享数据才有可能出现线程安全问题
    线程的调用是会随时发生的，无法预测
    内存模型有关.

> 多线程出问题的原因:

    1.线程之间交错运行
    2.内存区域的数据不一致

> ***原子性***

    原子性就是互斥的特性
    不是所有JAVA语句都是原子的
    原子：int a = 10;  除了double  long      常量 = 常量

> ***可见性***

![](https://github.com/q1206271031/photo/raw/master/JAVAweb/%E5%8F%AF%E8%A7%81%E6%80%A7.png)

    1.模型分为主内存和工作内存
    2.主内存只有一份(虚拟真实的内存)
    3.工作内存，每个线程各有一份(虚拟真实的CPU缓存)
    4.线程不可以直接操作主内存中的数据
        1).先load，把数据从主内存加载到工作内存
        2).修改工作内存中的数据
        3).在合适的时候，把数据保存回主内存，save
    5.这个和java内存区域划分是不同视角的事情，没有直接关系

> ***代码顺序性***

    1.为什么要重排序   优化执行效率
    2.哪些东西会对代码进行重排序      1).编译期间编译器javac
                                    2).运行期间JVM (JIT Just In Time)
                                    3). 运行期间，CPU (Intel )
    3.单线程情况下，重排序一定没问题(规定)
    4.多线程情况下，没有这个保证
    
> 大思路上，如何保证线程安全

    1.如果设计代码时，可以不进行数据共享，就尽量不数据共享
        不用属性+静态属性没问题
        ThreadLocal
    2.如果非要共享数据，尽量使用数据的副本(复制出来的数据) /不可变对象
        A传给B一份数据，如果B得到的数据只是一份复制，那数据其实也没有共享
        CopyOnWriteList
    3.确实要有数据共享了
        做到三个保证:原子/可 见性/重排序

> synchronized(同步) 锁

    1.语法:
    1)方法修饰符
```java
public synchronzied void method () {
...
}
```
    2)代码块的一种
```java
synchronized (对 象的引用) {
..●
}
```

> ***synchronized 锁的到底是什么***

    在java中，所有的对象中，都自带一个锁(内置锁instric lock/监视锁monitor lock)

![](https://github.com/q1206271031/photo/raw/master/JAVAweb/%E9%94%81.png)

```java
synchronized (ref) {
}
synchronized void method() {}
== void method() {
    synchronized (this) {}
    }
synchronized static void sMethod (){
synchonized (C. class) {}
}
```

> 判断是否是同一个锁(看锁的是否是同意对象)

![](https://github.com/q1206271031/photo/raw/master/JAVAweb/%E5%90%8C%E4%B8%80%E4%B8%AA%E9%94%81.png)

***互斥行为的产生必须***

    1.竞争双方都有请求锁的行为
    2.请求的是同一把锁(根据引用找)





















