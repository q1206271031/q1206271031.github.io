### JAVAWeb

> 冯诺依曼结构

![](https://github.com/q1206271031/photo/raw/master/JAVAweb/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.png)

> 除此之外JVM内存模型分为：

![](https://github.com/q1206271031/photo/raw/master/%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/JVM.png)

***其中***

    栈：方法调用，每调用一个方法，生成一个调用栈帧
        局部变量是在栈帧--局部变量在栈里
    堆：对象--属性
    方法区：类信息(Class对象)--方法/静态属性
    
> ***程序调度***
CPU从一个进程的执行切换到另一个进程的执行

> 什么情况下会发生进程调度:

    1.优先级更高的进程抢占(CPU)
    2.进程运行结束
    3. 等待外部事件(输入和输出的响应)
    4.时间片耗尽的时候(重要)
    5.主动放弃

> 类的加载：JVM在运行过程中把类字节码文件从硬盘加载到内存的过程

0.谁负责加载             类加载器
1.从哪找类字节码文件
2.放置的区域             方法区
3.过程

```java
public class Main extends Thread {
    @Override
    public void run() {
        while (true) {
            System.out.println("我是启动起来的线程");
        }
    }

    // jconsole
    public static void main(String[] args) {
        //创建子线程
        Main main = new Main();
        //启动线程
        main.start();
        //主线程程序
        while (true) {
            System.out.println("我是主线程");
        }
    }
```

### 多线程
为什么要使用多线程-多线程的优势

    1.使用多线程有可能提升效率
    某些场景下，如果任务的数量不够，启动线程占用的时间反倒成为耗时较多的，导致多线程不一定快
    2.某些场景下，主线程会阻塞，导致必须使用多线程工作: 
        (IO相关)
        模型更简单
        NIO/协程
    3. 某些场景下，主线程不允许做大量的计算，导致大量计算必须放到多线程中:
        (GUI图形界面开发)

> 在javaFX中

```javaFX
//添加Button按钮，提供onAction方法
<Button text="点我" GridPane.columnIndex="0" GridPane.rowIndex="0" onAction="#onButton"/>

public class Controller {
    @FXML public void onButton(ActionEvent actionEvent) {
        System.out.println("hello world");
        //主线程被卡死
        while (true) {}
    }
```

> 如何创建多线程对象Thread对象

    1.继承Thread类+覆写run方法
    2.实现Runnable接口+覆写run方法
      把Runnable 对象作为Thread类的构造方法的参数
    3. Thread 类也实现了Runnable 接口

```java
public static void main(String[] args) {
        //方法一 继承Thread， 并且直接启动
        MyThread myThread = new MyThread();
        myThread.start();
        //方法二 实现Runnable， 作为参数
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        //方法三 继承Thread，, 作为参数
        MyThread myThread2 = new MyThread();
        Thread thread1 = new Thread(myThread2);
        thread1.start();
    }
```

> 线程的匿名类和lambda

```java
//匿名类
new Thread(new Runnable() {
             @Override
             public void run() {
                 for (int x = 0; x < 100; x++) {
                     System.out.println("java" + "--" + x);
                 }

//匿名类
        Thread t = new Thread() {
            @Override
            public void run() {
            }
        };
        t.start();
//lambda
        Thread t2 = new Thread(
                () -> {}
        );
        t2.start();
    }
```

> 方法覆写

    方法名相同
    参数列表相同
    返回值类型“相同”
    访问限定符不能更小
    声明抛出的异常列表要“相同

```java
class Animal {}
class Bird extends Animal {}

class AnimalException extends Exception {}
class BirdException extends AnimalException {}

public class MethodOverride {
    public Animal getAnimal() throws AnimalException {
        return null;
    }
}

class MethodOverrideChild extends MethodOverride {
    @Override
    public Bird getAnimal() throws BirdException {
        return null;
    }
}
```

> 线程相关操作

***1.启动线程：***

start(),run()

***2.A线程要终止线程：***
        
        interrupt();建议性终止
        B如何知道A线程要终止B:
        1. B正在睡眠(sleep/wait/ join)
           通知是以异常的形式给到: InterruptedException,状态保持false
        2.B没有在睡眠,状态被修改为true
          1) isInterruped() 判断A是否让B死
            只获取当前状态，不修改状态的值
          2) Thread.interrupted ()
            获取当前状态，并把状态改为false

***3.多线程优势***

1.提升速度
2.编程模型简单

***4.JVM停止条件***

    所有非精灵线程都退出，才会退出，并不是主线程退出就退出。而所谓守护线程是指在程序运行的时候在后台提供一
    种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分
    。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任
    何非守护线程还在运行，程序就不会终止。

```java
public static void main(String[] args) {
        // Thread.currentThread()   静态方法
        // 获取当前线程的 Thread 对象
        Thread currentThread = Thread.currentThread();
        System.out.println(currentThread.getId());
        System.out.println(currentThread.getName());
        //优先级(越高越好)
        System.out.println(currentThread.getPriority());
        System.out.println(currentThread.getState());
        //是否后台线程
        System.out.println(currentThread.isDaemon());
        //是否存活
        System.out.println(currentThread.isAlive());
        //是否被中断
        System.out.println(currentThread.isInterrupted());
```




























